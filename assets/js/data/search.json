[ { "title": "Dvorak 6 Month Reflection", "url": "/posts/dvorak-6-month/", "categories": "Personal", "tags": "keyboards", "date": "2023-06-03 16:20:00 -0700", "snippet": "What is Dvorak?Dvorak is an alternative keyboard layout to QWERTY which aims to be more ergonomic and efficient. It places the vowels and commonly used characters on the home row. QWERTY, in contrast, has a pretty inefficient home row, with characters such as semicolon, J, and K. Dvorak is also optimized to maximize swapping back and forth between hands when building words, by placing vowels on the left hand and common consonants on the right hand.The Switch to DvorakI considered myself a pretty proficient QWERTY typist (many years of playing RuneScape as a teenager will do that to you). I could type faster than I could think in most cases, so why bother switching? There were a few reasons: I wanted to prevent future wrist pain by using a more ergonomic layout. I wanted to improve my typing technique. I never used my right pinkie while typing. This was something that I didn’t noticed until I started using Dvorak, where using your right pinkie is pretty much required since S is on your right pinkie, instead of semicolon on QWERTY, which is largely usused. I wanted to see if I could type faster after investing in learning a more efficient layout. I felt like I had pretty much hit my typing ceiling on QWERTY. Perhaps I’d be able to average 150 WPM after mastering Dvorak. Work was slow. It seemed like a fun thing to do while I was stuck at work waiting for builds to finish.With all these in mind, I decided to take the plunge. My QWERTY typeracer typing statsI started learning Dvorak by using this neat little website that allows you to practice Dvorak in your web browser without switching your keyboard layout over yet. It starts by only giving you words to type on the Dvorak home row and eventually expands its vocabulary as you continue the lessons. I tried to get in the habit of not looking at the keyboard layout to try to memorize where keys were. Once I knew were all the keys were, I fully committed to switching my keyboard over to Dvorak in the OS. The first 2 weeks were brutal. I was typing at around 5 WPM which made it incredibly frustrating to do anything on a computer because my brain would move at 20 times the speed of my hands. My right pinkie was also incredibly strained after forcing myself to use it. I couldn’t comprehend how anyone could type with their pinkie, especially when stretching it up to the top row. This subsided with time as the pinkie strengthened. After 1 to 2 months, I was only up to about 35 WPM. At this point, I was really wanting to quit and go back to QWERTY because I honestly thought the transition period would be a lot shorter. I found my QWERTY muscle memory kicking in a lot. By fully committing, I eventually got a handle on things.Was It Worth It?Fast forward to now, 6 months since I began the journey to learning Dvorak. I can currently type at around 90 WPM. To be completely honest, I thought that I would have reached my QWERTY WPM by now. I find that my accuracy and mastery of the bottom row isn’t quite there yet. So was it worth switching? It’s hard to say. I don’t personally believe Dvorak is worth switching to if you are a proficient QWERTY typist and only want to improve your speed. I don’t believe that my top speed will increase by much, even after I master the keyboard layout. At that point, I’ll be bottlenecked by my ability to think and process. Relearning to type did significantly improve my technique and that will pay off in the long run. One thing I didn’t expect is that I have completely forgotten how to type in QWERTY. So when using somebody else’s computer, I find myself needing to look at the legends to be able to type anything. I’m sure the muscle memory is still in there somewhere, so it will take some practicing to become “bilingual”. Overall, I feel that Dvorak is great to learn if you aren’t already a fast typist in QWERTY, or really care about ergonomics, but perhaps not worth learning if you are satisfied with typing in QWERTY." }, { "title": "Finding the Perfect Guitar on Sweetwater", "url": "/posts/sweetwater-scrape/", "categories": "Projects, Software", "tags": "guitar, python, web-scraping", "date": "2023-02-15 21:23:00 -0800", "snippet": "MotivationSweetwater is a great place to shop online for a guitar. One reason for this is that they display real images of guitars they have in stock, and let you choose the one you like best. I was in the market for a Les Paul, but the finish varies (sometimes dramatically) from guitar to guitar due to the burst being done by hand. After internally debating between two different Iced Tea bursts for the better part of an hour, I finally decided to pull the trigger. As I go to the checkout menu, I find, much to my dismay, that the one I had chosen had been sold during my bout of indecisiveness. I didn’t like the finish of the other guitar they had in stock as much, so I decided I’d wait for more stock. Being the impatient person that I am, I knew I would be refreshing the page hourly to try to snatch up a good looking one when it came in stock. That would probably end up driving me crazy. So, naturally, I started looking for an opportunity to automate this task.ResearchThe general idea was to create a program that can: Fetch in-stock listings from Sweetwater Send a notification when the program detects a listing is new Append an image and a link to the listing in the notificationIn order to do this, I started looking at the product page for the guitar I was interested in and noticed a few key pieces of identifying information. First, every product has a unique item ID listed on the page. Second, each guitar for a given item ID has an associated serial number. So the initial plan for the script was to check the webpage with the URL https://www.sweetwater.com/store/detail/{item id} and try to fetch a list of the serial numbers available on that page. The script would then compare the current listings with the previously seen listings to detect any new serial numbers.Sweetwater product pageScraping SweetwaterThe typical way to scrape a website is to perform an HTTP get request to fetch the site’s HTML content, parse it, and search it for the identifying information you’re looking for. In this case, I noticed that all the serial numbers are listed in the “Guitar Gallery” header, and the serial number for the currently selected guitar is listed on the left-hand side. So I opened the Chrome developer console and started searching for the serial numbers to see where they are in the HTML source.Sweetwater HTML sourceSure enough, the serial numbers are in listed in the serial-header__photos block. This could be parsed and the serial numbers could be extracted. The trouble is, the Guitar Gallery is only visible when there is more than one guitar in stock. If there is only one guitar in stock, there is no Guitar Gallery. This could be worked around by looking for the Guitar Gallery, and if it’s not there, using the left-hand side current serial number field instead. Ultimately, this was starting to feel ugly, so I decided to try a different approach.Another way to scrape a website is by monitoring network traffic on the site and looking for API calls in the HTTP requests. To do this, I opened Chrome’s Network tab in the developer console and refreshed the page. I then searched again for the serial number and found an HTTP request that returned a JSON object with exactly what I needed! The object contained the current available serial numbers, the URL’s of their images, the product name, and tons of other useful information.Sweetwater API callThe plan became a lot more simple. All that was needed was to make an HTTP request to the API, and parse the resulting JSON object.Writing the ScriptPython was my language of choice because it’s trivial to make HTTP requests and work with JSON. I started by testing out the HTTP request:import requestsid: str = LPS6ITNHurl: str = f&quot;https://www.sweetwater.com/webservices_sw/items/detail/{id}?format=serialcompare&quot;headers: dict = { # otherwise we get a 403 error &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&quot;,}try: with requests.Session() as session: request = session.get(url, headers=headers)except requests.HTTPError as e: raise IOError( f&quot;ERROR: failed to fetch products ({e.response.status_code})&quot; ) from etry: data = json.loads(request.text)except json.JSONDecodeError as e: raise IOError(&quot;ERROR: Failed to parse product JSON&quot;) from eInitially, the request would return a 403 Forbidden error. This was solved by populating the User-Agent field of the HTTP header, which provides some identifying information about the browser and the host OS to the web server. Some websites will block HTTP requests without this field to prevent non-browsers such as web scrapers from making requests.After this was working, I unpacked the JSON results into a Python object. I store the resulting objects in a set, which has the nice property of ignoring duplicate entries and supporting a set-difference operation to find objects belonging to one set but not another.class SweetwaterProduct: def __init__(self, name: str, serial: int, url: str, images: list) -&amp;gt; None: self.name: str = name self.serial: int = serial self.url: str = url self.images: list = images def __eq__(self, other) -&amp;gt; bool: if isinstance(other, SweetwaterProduct): return self.serial == other.serial return False def __hash__(self) -&amp;gt; int: return hash(self.serial)products: set = set() name: str = data[&quot;productName&quot;]try: items: set = set( map( lambda item: SweetwaterProduct( name=name, serial=int(item[&quot;serialNumber&quot;][&quot;number&quot;]), url=f&#39;https://www.sweetwater.com{item[&quot;serialUrl&quot;]}&#39;, images=[ item[&quot;images&quot;][view][&quot;images&quot;][&quot;750&quot;][&quot;absolutePath&quot;] for view in [&quot;angle&quot;] # can also use body, front, back ], ), data[&quot;comparableSerials&quot;], ) )except (KeyError, ValueError) as e: raise IOError(&quot;ERROR: Invalid key access when parsing product JSON&quot;) from eproducts |= itemsWith this code in place, finding new products is as simple as new_product = products - seen_products. And as a bonus, sold products can also by computed by sold_products = seen_products - products.To handle notifications, I decided to use a Discord Webhook. This enables posting content to a specific channel in a specific server by performing an HTTP post to a URL, which was enough for my needs.def post_discord(webhook: str, message: str, roles: list = []) -&amp;gt; None: content: str = &quot;&quot; for role in roles: content += f&quot;@{role} &quot; content += f&quot;\\n\\n{message}&quot; data: dict = {&quot;content&quot;: content, &quot;username&quot;: &quot;SweetwaterBot&quot;} try: requests.post(webhook, json=data) except requests.HTTPError as e: raise IOError( f&quot;ERROR: failed to post to discord ({e.response.status_code})&quot; ) from eResultsUltimately, I left the script running on a Raspberry Pi checking Sweetwater every 5 minutes. The discord integration provides a link and an image of new listings, notifications when listings are sold, and supports watching multiple different item IDs simultaneously.The Discord notificationsIf I were to continue developing this project, I would replace the Discord webhook with a full-fledged Discord bot, and allow the watchlist to be editable by interacting with the bot instead of hard-coding the watchlist. In the future I’d like to explore making a general purpose Discord bot with support for plugins that could be added in, like this one.After spending about 6 hours writing this script, I ended up purchasing a guitar only one day later. So was the script necessary? Probably not. But it was a lot of fun to write and taught me something new about web scraping. Plus, I’m very happy with the guitar I ended up with.My Gibson Les Paul Standard 60’s Iced TeaFeel free to check out the code here." }, { "title": "GameCube Adapter Reverse Engineering", "url": "/posts/gc-adapter-reverse-engineering/", "categories": "Projects, GameCube Controller", "tags": "wii, gamecube", "date": "2022-09-05 14:25:00 -0700", "snippet": "Discrepancies with EmulatorsDolphin Emulator, a Wii/GameCube console emulator, added native support for the official Nintendo GameCube controller adapter back in 2014. This was a huge step forward, allowing GameCube controllers to be used on emulator without the need for a custom driver to make the controller emulate a Xinput or Dinput device. Unfortunately, at the time of writing, the input mechanism in Dolphin does not behave the same as console. I first noticed this issue with an Arduino-based GameCube controller emulator I was working on. I specifically programmed the device to always report the joystick origin to the console as (0, 0).The origin on Dolphin is not (0, 0)After sifting through the Dolphin source code, it turned out that the GameCube adapter driver for Dolphin never sends the origin command to a controller. Instead, it interprets the first status response from the controller as the origin. Why was it done this way? The reason is because the interface that the GameCube adapter exposes to a programmer does not give direct access to sending JoyBus commands. Instead, there is a microcontroller inside the adapter that acts as a man-in-the-middle between the controller’s data bus and the USB interface. Clearly, it’s possible to send and receive data from the status command. But is it possible to do the same for an origin command?Using the USB InterfaceThe original reverse engineers of the adapter made a thread on GBATemp describing what can be done with the adapter. To summarize, there is a single USB interface descriptor that exposes two USB endpoints: one for writing and one for reading. Commands are written to the write endpoint (0x81) and responses (if any) are read from the read endpoint (0x02). The commands are not to be confused with JoyBus commands. Remember, there is a man-in-the-middle, so a different set of commands are used to trigger JoyBus commands. The command list is described below. Command Send Format (write endpoint) Response Format (read endpoint) 0x11Set Rumble [0x11, R1, R2, R3, R4] None 0x12Origins [0x12] [0x22, joyX[0], joyY[0], cX[0], cY[0], L[0], R[0], joyx[1], … ] 0x13Start Polling [0x13] None* 0x14Stop Polling [0x14] [0x24, 0x01 if previously polling else 0x00] 0x15Hard Reset [0x15] None. Will not respond further until reinitialized. 0x16Unknown [0x16, ...] ? 0x17Unknown [0x17, ...] ? *After polling is started, reading from the read endpoint will deliver data in the format[0x21,status[0], buttons0[0], buttons1[0], joyX[0], joyY[0], cX[0], cY[0], L[0], R[0],status[1], …]The status field of the polling response contains some information about the controller. Bits 4 and 5 describe the type of controller. Bit 4 is set for a normal controller, and bit 5 is set for a Wavebird controller. This can be used to check if a controller is connected. If no controller is connected, the response for that controller is filled with 0x00. The meaning of the other bits is unknown. Interestingly, handling controllers is always done with all four at a time as opposed to interacting with a single controller.The buttons fields contain the state of the buttons for a particular controller. The 2-byte value is described below. The format is almost the same as the JoyBus format, with the exception of the error/origin bits being omitted. Bit Description 15 Unused 14 Unused 13 Unused 12 Unused 11 L (1 = pressed) 10 R (1 = pressed) 9 Z (1 = pressed) 8 Start (1 = pressed) 7 D-Pad Up (1 = pressed) 6 D-Pad Down (1 = pressed) 5 D-Pad Right (1 = pressed) 4 D-Pad Left (1 = pressed) 3 Y (1 = pressed) 2 X (1 = pressed) 1 B (1 = pressed) 0 A (1 = pressed) You might have noticed there’s an Origins command. Great! As far as I could tell, nobody had actually implemented any kind of driver that actually uses the Origins command yet. I tried it out myself and was not having much luck. To understand why, we need to take a look at what the adapter is doing under the hood.The Hardware State MachineLet’s look into what is actually happening on the JoyBus side. When the adapter is first powered on, it does not communicate with the controllers at all. Communications with the controller only start once the Start Polling command has been issued. After this command is sent, the adapter issues an ID JoyBus command followed by repeatedly sending the origin command. The adapter issues these repeated origin commands until a status response has been read from the read endpoint.GameCube adapter sending the origin command repeatedlyGreat! So the adapter is capable of sending the origin command. It’s also worth noting that the adapter always communicates at a frequency of 1kHz over the JoyBus link, regardless of what the USB driver is set to read at. By default, your PC is probably polling slower than 1kHz! The next question is, why am I having difficulty retrieving the origin? And is there a way to trigger it when the adapter is already polling?The answer is that you cannot reliably read the response from requesting the origins while the adapter is polling. Because the response to any given command to the adapter is received on the read endpoint, you may receive a status response when you read from the read endpoint, or you may receive the response to the command that you wanted to send, due to the asynchronous nature of how polling is implemented on the adapter. This is probably the reason why each response to a command to the adapter comes with a unique byte at the beginning of the response, indicating what command the response is for. Alternatively, a Stop Polling command can be issued to make requesting the origins synchronous, then a Start Polling command can be reissued after the origins request. This procedure may even be necessary, if the status response overwrites the origin response.The answer to my second question is even more complex. After some experimentation, there is no easy way to get the adapter to ask the controller for its origin again once it leaves the repeated origin state. This is disappointing because ideally, Dolphin would do this any time a game is started. There is, however, a way. The Hard Reset command (dubbed by the GBATemp thread as the Kill command), was given the description: “Turns off the adapter and requires it to be unplugged and reconnect to begin working again”. This is actually not true. This command simply requires the USB interface to be reinitialized before using the adapter again. By sending the Hard Reset command and reinitializing the USB interface, controllers will be put back into the repeated origin state.ConclusionIn summary, utilizing the origin command properly is feasible, but non-trivial. To correctly ask for a controller’s origin, a driver needs to: Send the Hard Reset command to the adapter Reinitialize the USB interface Send a Start Polling command (to put the controller into the repeated origin state) Send a Stop Polling command (and read the response, to be able to synchronously receive the response of the Origins command) Send an Origins command, and receive the response through the read endpoint Send a Start Polling command, to resume pollingThere may be another way, perhaps utilizing one of the two unknown commands, but this is the only way that I’ve discovered so far. I’m not sure the Dolphin devs want to put in the effort to achieve this level of accuracy, as it makes the driver a lot more complicated. Their current driver, at the time of writing, assumes the read endpoint is only for receiving status responses. For most controllers, a status response will be equivalent to the origin response anyway. There are some niche cases where they aren’t though.I wrote a driver that supports the Origins command using Python with PyUSB. Feel free to play with it here." }, { "title": "Adding a Removable Cable to the FightStick Alpha", "url": "/posts/fightstick-alpha-mod/", "categories": "Projects, Mods", "tags": "hardware, 3d-printing", "date": "2022-09-04 09:57:00 -0700", "snippet": "MotivationBack when Street Fighter V came out, I decided I wanted to learn how to play. I quickly learned that most players of Street Fighter, or fighting games in general, play on an arcade-style controller (colloquially referred to as fight sticks). I ended up purchasing a entry-level FightStick Alpha from MadCatz. After swapping out the stick and buttons, it was a pretty good stick. My only gripe with it was that the long USB cable was tethered to the stick, making it annoying to travel with or pack up. On a slow day at home, with the power of a 3D printer and a soldering iron, I decided to see if I could replace the cable with a port for a removable cable.Cable Holder MechanismThe stock cable was soldered to the PCB in the case. The cable exits the case and is held in place by a plastic piece that’s screwed into the case. The problem is, the connector for the removable cable would need to be on the outside of the case. So I needed a way to affix the connector on the outside of the case while having the connector wired to the PCB on the inside of the case. Wanting to avoid using glue, I decided to see if I could create a 3D model of the original plastic piece that held in the cable, and add a mounting point for a connector to it.3D model of the cable holder3D printed cable holder with USB-C connector (left) vs. stock cable holder (right)AssemblyAfter I measured everything out with a caliper and recreated the stock cable holder in Fusion 360, I added screwposts for a USB-C breakout board that I had laying around. I positioned the connector such that it would be exposed to the outside of the case without exposing too much of the PCB, to hide the wiring. After soldering some wires from the main PCB for D+, D-, 5V, and ground, the assembly was ready to go.Full assemblyEverything screwed in and fit nicely when compared to the original cable holder. It’s difficult to even tell that there’s a 3D printed piece at all! The connector is relatively well hidden on the bottom of the stick. Now when I want to play, I just grab a USB-C to A cable and I’m good to go.Connector view from the outside" }, { "title": "GameCube Controller Reverse Engineering (Part 2)", "url": "/posts/gc-controller-reverse-engineering-part-2/", "categories": "Projects, GameCube Controller", "tags": "wii, gamecube", "date": "2022-09-04 00:11:00 -0700", "snippet": "This is a continuation to GameCube Controller Reverse Engineering (Part 1). Be sure to check that out if you haven’t already.Decoding the CommandsTo validate all of the previous protocol research, I created a protocol decoder for the Saleae Logic 2 software. Feel free to download it and try it here. Not only did this allow me to annotate commands so I could identify commands at a high level, but the recent addition of FrameV2 support allows me to generate a table of command outputs to easily see the different fields of a command-response frame. The software also allows you to jump to a particular frame by selecting it from the table. The frame table can also be easily searched or exported for further analysis.Annotated commandsFrame tableHere are some captures if you want to take a look at them in the Logic 2 software. Console Boot Capture Super Smash Bros. Melee Boot CaptureDesigning a Replacement ChipAfter I had a solid grasp on the protocol, I wanted to see if I could replace the ASIC on an OEM GameCube controller with a very small carrier PCB containing a microcontroller - the idea being that the carrier PCB would have castellated edges that could solder down directly to the footprint of the ASIC. Before I could do that, I had to figure out the pinout of the existing ASIC. To do that, I found some scans of the OEM PCB on Acid Mods forum. Unfortunately, the scans weren’t very high quality, due to the compression of the forum. I contacted the original poster, RDC, and he was generous enough to send me the original high quality scans. I was able to map out the pinout of all the analog and digital inputs, and also discovered that original ASIC is clocked from a 4MHz oscillator. I added an option to use it on my custom PCB. ) Now that I had a pinout, I was able to take a crack at making my own board. My first attempt used OSHPark’s 0.8mm service to make the board as thin as possible. Unfortunately, it was still pretty difficult to solder down, and I didn’t get the pitch quite right on the pads.First attempt at the PCBFor the second attempt, I switched to OSHPark’s flexible PCB service. The cost difference was negligible with a PCB so small. This time it fit perfectly. I implemented the controller protocol using an STM32 microcontroller.Second attempt at the PCB. Much better!And there it was! I had a working GameCube controller (again). Although it isn’t any better than a regular controller, it was a very interesting project academically, and it opens up opportunities for creating a full replacement board down the line. There will be more to come." }, { "title": "GameCube Controller Reverse Engineering (Part 1)", "url": "/posts/gc-controller-reverse-engineering-part-1/", "categories": "Projects, GameCube Controller", "tags": "wii, gamecube", "date": "2022-09-04 00:10:00 -0700", "snippet": "MotivationI’m not the first one to reverse engineer the GameCube controller protocol. However, a lot of the information out there is either incomplete or inacccurate. With the intent to emulate the GameCube controller protocol on a microcontroller, I took a deep dive into understanding the protocol.Physical InterfaceThe first step in reverse engineering a hardware protocol is to inspect the physical interface. The GameCube controller protocol is actually an extension of the Nintendo 64 controller protocol, which uses single-wire bidirectional communication. The data wire is open drain meaning it is pulled-up via a pull-up resistor (to the 3.3V rail) and when the console or controller wants to talk on the bus, they drive the line low to communicate. This prevents collisions on the bus and is used for other bidirectional single-wire data line protocols such as I2C.GameCube controller pinoutWhat makes the GameCube/N64 protocol interesting is the omission of a clock. Most common protocols have a data line and a clock line, where the clock gives a reference for when to read the data line to check if the current bit is a 1 or a 0. Because there is no clock, there must be timing pattern to indicate 1s or 0s.Capturing the ProtocolThe next step after identifying the interface is to capture it in action. One way to do this would be to use an oscilloscope, which creates a graph of voltage versus time. However, because we know that this protocol is a digital protocol (1s and 0s) a logic analyzer is preferable. A logic analyzer performs the same function as an oscilloscope, but only shows 1s and 0s instead of an analog waveform. This means that it’s possible to capture a lot more data in a lot smaller file size, and it’s easier to analyze.To take this capture, I opted to use a Saleae Logic Pro 8. It is compatible with their Logic 2 software which is an absolutely fantastic piece of software. It is much more intuitive and user-friendly to use than alternatives such as PulseView. The huge advantage to using the Logic software is that it allows you to build a protocol decoder. A protocol decoder can run on a waveform and display it in a user-readable format, instead of inspecting it one bit at a time. The Saleae Logic hardware is no doubt quite expensive. There are, however, cheap knock-offs that also work with the Logic software. They can get the job done, but in my experience only work at pretty slow sample rates, are prone to randomly disconnecting, and do not have the ability to capture analog data as well. The official hardware is well worth the investment.Saleae Logic Pro 8 connected to GameCube controllerEquipped with the Saleae Logic, I took some captures of controller’s data line. The protocol is a command/response interface; the console sends a command, and the controller sends a response. Bits are encoded based on the low time of the signal. The console sends bits with a period of 5us, while the controller sends bits with a period of 4us. A 0 is encoded by driving the line low for 75% of the period, and releasing it for the remaining 25%. A 1 is encoded by driving the line low for 25% of the period, and releasing it for the remaining 75%. When the command or response is completed, a 1 bit is sent as a stop bit. The timings are summarized below. Bit Low time (us) High Time (us) Total Period (us) 0 (console) 3.75 1.25 5 0 (controller) 3 1 4 1 (console) 1.25 3.75 5 1 (controller) 1 3 4 When there is no controller plugged in, the console polls for controllers by sending the ID command repeatedly until a controller responds. If a controller fails to respond within ~65us of receiving a command, the console will start sending the ID command again.Reset Command (0xFF)A reset command notifies the controller to reset, then responds as if it received an ID command.ID Command (0x00)ID commandIn this image, the ID command issued by the console is displayed in red. Note the 8 low bits followed by a high stop bit. The controller responds with a 3 byte bitmap, which tells the console some information about itself, followed by a stop bit. The first 2 bytes describe the type of controller, described in the table below (source). This table is incomplete. Please reach out if any more accurate information can be provided.ID Response Bytes 1 and 2 Bit Description 15 Controller is wireless (1 = yes) 14 Controller supports wireless receive? (1 = yes) 13 Controller supports rumble (0 = yes) 12 Controller type (always 0? maybe reserved for future consoles?) 11 Controller type (0 = N64, 1 = GameCube) 10 Wireless type (0 = IF, 1 = RF) 9 Wireless state (0 = variable, 1 = fixed) 8 Non-standard controller (1 = standard GameCube controller) 7 ? 6 ? 5 Wireless origin (1 = valid) 4 Wireless fix id (1 = fixed) 3 Wireless type (0 = normal, 1 = non-controller?) 2 Wireless type? 1 Wireless type? 0 Wireless type? The third byte describes the current status of the controller. This byte is context dependent (the content is different for N64 controllers compared to GameCube controllers).ID Response Byte 3 Bit Description 7 Error (1 = error on last transfer) 6 Error (latched) 5 Origin has been sent to console (0 = yes) [4:3] Rumble mode [2:0] Poll mode Status Command (0x40)Status commandThe status command is the most important command. It sends the console the current state of the buttons, joysticks, and shoulders, controls the format they are sent in, and controls rumble. In contrast to the previous commands, the status command has 2 argument bytes that are sent by the console after the command byte. The first argument is the rumble mode and the second argument byte is the poll mode.Status Command Argument Bytes Byte Description 1 Command 2 Rumble mode 3 Poll mode Rumble ModeThe rumble motor can be in one of three states: Off (rumble mode = 0) On (rumble mode = 1) Brake (rumble mode = 2)When the motor is in the on state, 5V is applied to RUMBLE+ and 0V is applied to RUMBLE-. The motor will vibrate. When the motor is in the off state, 5V is applied to RUMBLE+ and RUMBLE- is left open circuit. The motor will stop vibrating. When the motor is in the brake state, 0V is applied to RUMBLE+ and 0V is applied to RUMBLE- (they are shorted). The motor will abruptly stop vibrating.Poll ModeThere are 5 poll modes that the console can choose from. The poll mode determines the format of the analog values in the status response. Poll mode 3 is by far the most commonly used format. It allows full 8-bit resolution of all the (used) analog inputs. Luigi’s Mansion infamously uses poll mode 0.Status Response (poll mode = 0) Byte Description 1 and 2 See here 3 Joystick X 4 Joystick Y 5 C-Stick X 6 C-Stick Y 7 [7:4] L Analog [3:0] R Analog 8 [7:4] A Analog [3:0] B Analog Status Response (poll mode = 1) Byte Description 1 and 2 See here 3 Joystick X 4 Joystick Y 5 [7:4] C-Stick X [3:0] C-Stick Y 6 L Analog 7 R Analog 8 [7:4] A Analog [3:0] B Analog Status Response (poll mode = 2) Byte Description 1 and 2 See here 3 Joystick X 4 Joystick Y 5 [7:4] C-Stick X [3:0] C-Stick Y 6 [7:4] L Analog [3:0] R Analog 7 A Analog 8 B Analog Status Response (poll mode = 3) Byte Description 1 and 2 See here 3 Joystick X 4 Joystick Y 5 C-Stick X 6 C-Stick Y 7 L Analog 8 R Analog Status Response (poll mode = 4) Byte Description 1 and 2 See here 3 Joystick X 4 Joystick Y 5 C-Stick X 6 C-Stick Y 7 A Analog 8 B Analog The astute reader will notice mention of an A and B analog. This was likely a feature that was dropped for production. In fact, I’m pretty confident that there are A and B analog pins on the controller ASIC that probably work and are left unconnected. It would be interesting to see if someone were to find them and apply voltage to them if they would respond accordingly in the response.Status Response Bytes 1 and 2The first 2 bytes in the response of a status command describe the state of the controller’s buttons and status, shown in the table below. Bit Description 15 Use the controller origin (1 = yes, not confirmed) 14 L (1 = pressed) 13 R (1 = pressed) 12 Z (1 = pressed) 11 D-Pad Up (1 = pressed) 10 D-Pad Down (1 = pressed) 9 D-Pad Right (1 = pressed) 8 D-Pad Left (1 = pressed) 7 Error (1 = error on last transfer) 6 Error (latched) 5 Origin has been sent to console (0 = yes) 4 Start (1 = pressed) 3 Y (1 = pressed) 2 X (1 = pressed) 1 B (1 = pressed) 0 A (1 = pressed) Poll RateBecause the GameCube had no kernel, controller polling is done completely in hardware. The console configures the poll rate by configuring the number of horizontal lines that are rendered between successive polls (source). Many games poll at 60Hz, but some games, such as Super Smash Bros. Melee, poll at 120Hz. The console is capable of polling at speeds as high as 2KHz.Origin Command (0x41)Origin commandThe origin command tells the console what the state of the controller was when it came out of reset. It is used to calibrate the analog controls if they are naturally uncentered. The origin value gets subtracted off of any given analog input before a game processes it. For example, if the joystick x-axis origin was at x = 5 (assume center is 0), and the current value is 5, the value a game would use would be the current value minus the origin value, resulting in a value of 0. In other words, it “shifts” the joystick’s center to the origin value. This command (or a recalibrate command) immediately follows the response of an ID command. The controller responds with 10 bytes. The first 2 bytes are the same as the first 2 bytes in the response to a status command. When the console requests a controller’s origin, the Origin has been sent to console bit in the ID, origin, and status commands are cleared.The remaining 8 bytes describe the analog inputs. These bytes are described in the table below.Origin Response Bytes 3 to 10 Byte Description 3 Joystick X 4 Joystick Y 5 C-Stick X 6 C-Stick Y 7 L Analog 8 R Analog 9 A Analog 10 B Analog Recalibrate Command (0x42)Recalibrate commandThis command is functionally very similar to the origin command. It tells the controller to capture new origin values and report them to the console. The response format is the same as an origin command. However, it does have 2 command arguments like the status command. It’s unclear whether these arguments are used. They are both always 0x00. This command is sometimes used instead of the origin command. For example, when booting up the GameCube or Wii system menu.“Long” Status Command (0x43)This command was found by fuzzing the controller and is apparently only used by the GameCube Service Disc (source: Extrem). It has 2 command arguments, like the recalibrate command, that are possibly unused. It returns the controller status in the 10 byte format of an origin.To Be Continued..Check out part 2 here." }, { "title": "Portable Wii Endgame", "url": "/posts/2021-wii-portable/", "categories": "Projects, Portables", "tags": "wii, gamecube", "date": "2022-09-03 15:40:00 -0700", "snippet": "Back at it AgainOne of the limitations of creating a portable Wii has always been ergonomics. Creating an organic design that feels good in the hands is an extremely non-trivial task. Wouldn’t it be great if it were possible to capture the feeling of a GameCube controller in a portable Wii? Enter the Ashida.The AshidaThis design was brilliantly engineered from Wesk on BitBuilt. “How does it look so close to an original GameCube controller?”, you might ask. Wesk used a 3D Scanner, which uses reflected light to reconstruct a 3D model of a real-world object. Unfortunately, with such a complex shape, the results aren’t perfect. Areas of the controller where it’s difficult for light to reflect, such as small pockets, will have deformities in the model. Wesk invested a lot of time remeshing and repairing the model to deal with this. After all was said and done, he cut the model in half and added the design for a portable Wii in between the two halves of the shells; a true game-changer for Wii portable design of the future. Check out his worklog here.After his initial success, he graciously open-sourced the case design and collaborated with 4LayerTech to create a kit so that anyone can build their own Ashida. After seeing this, I knew I had to build one for myself. It is truly a no-compromises Wii portable.Building it MyselfI purchased the needed PCBs from 4LayerTech including the RVL-PMS-2 (power management), U-AMP (audio), GC+ (controller), as well as the Ashida carrier board kit and the associated components for it. I also purchased a brand new Nintendo GameCube controller to harvest the joysticks, buttons, and other parts from. The build uses two 21700 cells for a total of a 10Ah capacity. In total, the parts costed me around $250.The CaseA popular option for printing cases these days is having them professionally printed by services such as JLCPCB or PCBWay. These services can provide extremely high quality prints at extremely low prices. Despite this, I wanted to try printing the case myself. I stumbled across Fusion Filament’s Electron Indigo filament and thought it would be cool to print in this filament to try to get somewhat close to Nintendo’s signature indigo color without having to paint the case. My Prusa MK3S could just barely, and I mean barely, fit the Ashida print on its print bed. The print was oriented at around 45 degrees to reduce layer lines on the front of the case. Each half of the case took around 30 hours to print and used a total of around half a kilogram of filament. As you can see, there is a lot of support material. I spent at least two days post-processing the case. This involved removal of support material, and sanding the case so that it felt smooth in the hands. I used a sanding disc attachment for my dremel to make the process a bit easier early on, then eventually manually wet sanded at higher grits up to 2000 grit. In hindsight, it probably would have been fine not sanding it at all, but it did help the hand grips feel a lot smoother. I ran into a lot of problems with tolerances around the Z buttons. I ended up spending a lot of time sanding those areas, and as well, needed to trim the physical button down to get it to fit right. I also had to remove the OEM bracket from the shoulder buttons or they would get stuck, due to tolerances. Note to self: make sure everything fits perfectly before putting in all the electronics! If I were to do it again, I would probably just order a resin printed shell from one of the aforementioned services.The finished caseElectronicsAt this point in my portablizing career, I have trimmed many a Wii. Wiring everything up was just going through the motions again. 4LayerTech’s product page for the Ashida PCBs had some pretty nice wiring diagrams of how to connect everything together. A nice thing about the Ashida design is that it uses battery terminals that friction fit into the case instead of requiring soldering directly to the cells. This also makes it easy to swap out cells, or just remove them if you need to cut power to the system to repair something. It also has a channel underneath the heatsink to route wires through, which was really handy for organizing the wiring and getting it to the top half of the case. I invested a lot of time to make the wiring for this build neat. All of the custom PCBs were a great assist to this as well.The final internalsThe electronics themselves have some interesting features too. A USB-C port can be used to charge the system using USB Power Delivery. That same port can be used to load games onto the internal flash drive when the system is powered off. There is an RGB LED battery life indicator, and PWM fan control based on the system temperature. Firmware for the electronics can be updated via the custom homebrew loader RVLoader. A potentiometer is used to adjust the system volume (which I prefer over push buttons), and headphones are supported as well. The audio itself is high quality digital audio using the Wii’s I2S interface. The display uses the Wii’s native VGA support (which is normally disabled in software, but can be enabled via RVLoader plus some extra wiring to the HSYNC and VSYNC pins that are not connected on the Wii PCB), which looks fantastic on the IPS 5” screen. The colors are vibrant and the viewing angles are great. The batteries last for a solid 6 or so hours of gameplay.RetrospectiveThis build is by far my personal favorite. I’ve been playing through Sonic Adventure 2: Battle, Luigi’s Mansion, and Paper Mario: The Thousand Year Door on this portable. I’m extremely proud of how far the console portablizing community has come. Every time it seems like we’re in the endgame, something new blows everyone away. This will likely be the last portable console I build for awhile. My future plans are to contribute elsewhere in the retro-gaming community.See the full worklog here." }, { "title": "Building the Perfect Travel Wii", "url": "/posts/wii-micro/", "categories": "Projects, Portables", "tags": "wii, gamecube", "date": "2022-09-02 22:45:00 -0700", "snippet": "Why Bother?As a competitive Super Smash Bros. Melee player, I always have a Wii and CRT TV on hand to boot up a game of Melee. I’ve traveled to many different venues, and try to bring a setup when possible to help out the scene. Unfortunately, a full Melee setup is a lot to carry: a CRT TV, a Wii, the Wii’s power brick, and AV cables. I wanted something a bit more lightweight and easier to use. I set out to create a travel-optimized Wii at the lowest possible cost. The goal was under $100.First PrototypeTwo of the victimsI built a total of three of these - two of them simultaneously after the initial prototype. This build features a more conservative trim of the Wii motherboard, preserving the USB ports, AV port, and all four of the heatsink screwposts. Since the minimum width of the build was constrained by the width of the GameCube controller ports, there’s nothing to gain by relocating these components. After sanding down the edges of the Wii motherboard and controller ports to prevent the inner layers of the PCB from shorting, I was almost ready to go on wiring things up. Before that, I needed to cut down and sand the sensor bar connector, which is on top of the AV connector. The added height of the sensor bar connector would limit the minimum thickness of the final product, which I wanted to be as slim as possible.A short while with the dremel later, I got to work on the wiring. For this first prototype, I used the trusty PTH08080WAH voltage regulators that I had used in my first portable Wii to power the system. I then wired up the 5V, 3.3V, 1.15V, and 1V rails to system. I decided to use USB-C as the power source to supplement the need to carry around a power brick. This would allow the console to be powered from a simple phone charger. USB-C supports 15W at 5V (with an appropriate AC adapter), which is more than enough to power the ~7W that a (mid to late revision) Wii requires. This also allows the omission of a 5V voltage regulator, which reduces cost. Another design consideration I had to make was whether or not I should trim the GameCube controller port PCB down all the way. Trimming it as far as I did severed the 3.3V and 5V traces between the ports, so those would have to be manually rewired back together. A bit of a pain, but it reduces the minimum overall size of the build. Another minor setback I ran into was the audio pre-amp. 5V was not enough for it to reliably work, so I simply removed it and shorted the outputs to the inputs. The audio still sounds fine, but requires the TV audio to be turned up a bit extra.The Wii all wired up3D DesignAt this point, the project was electrically done, and it was time to start thinking about an enclosure. By doing the wiring first, I had a pretty good idea of the form factor that I wanted. A cooling solution did need to be kept in mind though as the 3D design came together. I used a similar cooling solution to that in my first portable Wii: a 35x35x7mm blower fan and adjacent 35x35x7mm heatsink with a copper plate to thermally connect them to the Wii CPU and GPU. Small dabs of thermal paste were placed on both sides of the copper plate. I started by rigorously recreating a 3D model of the Wii and all of its peripherals. I then designed the case around these models in the smallest form factor I could create. The enclosure was designed in three pieces: the top, which contained the mounting posts for all the PCBs, the walls, which contained the cutouts for the ports, and the bottom. It was done this way so that the ports could be friction fit into the holes before the rest of the case got in the way, due to it being such a tight fit in the x-y plane.A look at the 3D modelsAfter several rounds of printing and tweaking the model, it was finally complete. I reused the screws from the Wii to assemble the final unit. The end result was some of the cleanest wiring I had done to date. I ended up selling this unit, which gave me an excuse to improve the design.Internals of the first prototypeTake TwoThe second time around, I made some adjustments to the design. First, I created a custom PCB to replace the PTH08080WAH voltage regulators. This allowed for a cleaner wiring job and another thing that could be screwed down into the case. I also created a USB-C connector board to replace the off-the-shelf one I was using, which could not be secured to the case as well as I liked. Lastly, I printed the case using the PEI powder-coated textured bed for my 3D printer. This gave the outside of the case a far more polished look.Custom power PCBs for revision 2Updated case designI ended up very happy with the final product. With these modifications, everything slots in perfectly and very little extra wiring is necessary. I was able to build both of the second-revision units from assembled Wii to assembled Wii Micro in one day. I ended up selling one of those two, but I hold on to the third one to this day. It has endured hundreds of hours of gameplay and still works like a charm.The final productRetrospectiveThis project taught me a lot of new things. It was the first time I had seriously designed my own PCB for a finished project. It was the first time I had done my own 3D printing (and all the tuning that comes with it…). I have to say that my favorite thing about this project, though, is that I use it all the time. Many of my projects I build because they’re fun to design and build, but I often hardly use them after they’re built. I’ve taken this project to many Smash tournaments, and use it at home whenever I want to play on a Wii. There’s something great about that.See the full worklog here." }, { "title": "From Knowing Nothing to Building a Portable Wii", "url": "/posts/2018-portable-wii/", "categories": "Projects, Portables", "tags": "wii, gamecube", "date": "2022-03-20 09:49:00 -0700", "snippet": "The BeginningI somehow stumbled across this video of a portable GameCube. I was instantly obsessed and knew I had to make one too. At this point in time, I had recently graduated high school, and had zero experience working with hardware in any capacity. Without a clue on how to proceed, I desperately tried reaching out to the author of the video, Zack Hale. I was shocked when he actually responded and offered his guidance at any time.Conversation with Zack HaleAfter going back and forth with Zack for some time, I was eventually led to Kasar’s GameCube portable guide on ModRetro which became my bible. With the sacred texts at hand, I determined what I would need to build the portable. I wanted to make a replica of Zack’s portable GameCube. A GameCube (not a Wii yet, more on this later..) Some way to remove the enormous disc drive and replace it with an SD card or USB drive Batteries to power the console and a BMS for charging A controller to embed into the portable A memory card to store game data A display Speakers An enclosure to house everything inI began sourcing all the parts. To replace the disc drive, I picked up a (no longer produced) WASP fusion modchip, which allows GameCubes to boot games from an SD card. I got some 18650 cells for powering the console, and I chose the same ZN40 case from Polycase that Zack had used for his portable.The First AttemptI had never attempted soldering before. My first task to get started would be relocating the memory card. I (forcefully) removed the memory card ports from the GameCube motherboard and soldered a memory card PCB directly to the port vias. I also soldered an SD card socket to the other memory card port (a GameCube memory card is basically just an SD card) which would be used to load the homebrew that allows the SD card game loading.The first solder jointsAs it often happens, I decided to go down the rabbit hole of trimming the motherboard (cutting off the non-important parts of the board with a rotary tool) and using custom voltage regulators to improve the efficiency and reduce the motherboard size footprint. I created a voltage regulator module using several TI PTH08080/PTR08060 modules to provide the GameCube with 5V, 3.3V, and 1.9V. To make things even more complicated, I decided that this portable would have video out via the OEM composite video port, and 4 GameCube controller ports to plug in external controllers. Sometimes you need to walk before you run, and that’s a takeaway I would soon discover. In addition, it was around this time I joined the BitBuilt modding community, where the resounding advice was to use a Wii for making a portable GameCube instead of a GameCube itself. The Wii can natively run GameCube games, can load games from USB without requiring a modchip, produces half the heat and draws half as much power. But at this point, I was too stubborn and invested to not see the GameCube portable through with what I had. I had wired up pretty much everything, I had the case laser cut by a friend to have the cutouts I would need, and I just needed to put everything in the case and close it up. Easier said than done.In retrospect the internals were hideousThis is when disaster struck. After many successful boots, the board inexplicably started smoking. To this day I’m unsure if it was my fault or something out of my control. Apparently, trimmed GameCube motherboards are pretty volatile. This is when I finally gave in and decided to restart everything from scratch with a Wii.The Switch to WiiI picked up a Wii off of Craigslist for $10, and got to work. I installed the required software, trimmed the motherboard, and built a new set of custom voltage regulators (the Wii uses 5V, 3.3V, 1.15V, and 1V). The Wii can be trimmed shockingly small. Nearly all the components required for a Wii to work (the CPU, GPU, RAM, and NAND flash memory) are all located nearby each other. It’s really not as hard as it looks, either.Trimmed Wii motherboardThe plan was to cram these new internals into the existing case. While I was working towards this, I was growing increasingly resentful towards the case. It was at this time that hobbyist 3D printing was becoming mainstream and affordable. The future of portablizing was shifting towards 3D printing a custom enclosure instead of “frankencasing” an enclosure together. A 3D printed enclosure can be entirely customized for the project at hand. If designed right, one can add screwposts for everything. This makes the assembly cleaner and prevents you from having to use glue. 3D CAD was entirely foreign to me, but I thought it would be a fun thing to learn. I tried out Fusion 360 because it is free for hobbyists and is much more versatile than primitive CAD tools like SketchUp. After what’s likely to be close to 100 hours, I finally had a case ready to print.3D model of the caseI painstakingly measured dimensions and cutout sizes using a caliper. The cutouts for the stock GameCube buttons were particularly challenging to recreate. The other challenge was that I did not own a 3D printer at the time. Furthermore, this was before the time you could affordably purchase 3D models from online services. Luckily, I had a friend in Texas who was willing to print the case for me. However, that was not at all close to me, so the case needed to be shipped. Which means I’d better get all the dimensions right, or there would be a long time between test prints. Everything fit on the second attempt, which in my opinion is very impressive.In order to get a smooth finish on the case, I coated the print in Bondo to fill in all the layer lines. I then wet-sanded the case for hours until it was smooth as glass. The post-processing was a ton of work, and I’m not sure if I would go through that level of effort again. I wanted a color close to the Nintendo indigo, and I found Tamiya’s TS-24 was pretty darn close. I spray painted and clear-coated the case. It was so close to being finished.The finished internalsThe display was modded to run from 5V by bypassing the 5V regulator on the driver board. For the controller, buttons and 3DS joysticks were connected to an open source microcontroller project called GC+ to emulate the controller. IR LEDs were placed in the front of the case to add Wiimote compatibility. Finally, the case was closed and the full system integration was complete.RetrospectiveThis project took a year to complete after its initial inception. The internals are something I probably wouldn’t be proud of today, but for my first electronics project it was beautiful. The console still works 4 years after it was completed. I learned many new skills since beginning this project. I learned how to solder (even to tiny traces and vias!), how to use 3D CAD tools, and more about circuits than I had learned in school. It is truly valuable to work on a functional engineering project outside of academia. It becomes personal, and one’s passion can truly shine. Before I even finished this project, I had dozens of new and more ambitious projects I now wanted to complete.See the full worklog here." } ]
